<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trabalho 2 - CG</title>
</head>
<body onload="init()">

    <canvas id="cg" height="720" width="1320"></canvas>
    
</body>
<!-- 
    attribute - Cada elemento poderá ter um atributo diferente
    varying - A cada momento a 
    Uniform  - todos os elementos terão o mesmo valor para essa variável
 -->
<script id="vertex-shader" type="notjs">
    // position -> vetor de coordenadas do vertice -> [x, y, z, 1]
    attribute vec4 position;

    //texCoord -> vetor com as coordenadas de textura do vértice -> [tx,ty]
    attribute vec2 texCoord;

    // fcolor -> vetor com os valores RGBA de um vértice -> [R, G, B, A]
    attribute vec4 fcolor;

    //Matrizes de transformação
    uniform mat4 transf_projecao;
    uniform mat4 transf;

    //Variavel para inserir cor no frag shader
    varying vec4 color;
    //Variavel para inserir as coordenadas de textura no frag shader
    varying vec2 v_textCoord;

    //Atributo para as normais
    attribute vec3 normal;
    varying vec3 v_normal;

    uniform vec3 light_position;
    varying vec3 pointToLight;

    uniform vec3 cam_pos;
    varying vec3 pointToCam;


    void main(){
        //Atribuição do valores
        color = fcolor;

        v_textCoord = texCoord;

        gl_Position = transf_projecao*position;

        v_normal = (transf*vec4(normal,1.0)).xyz;

        pointToLight = light_position - position.xyz;

        pointToCam = cam_pos - position.xyz;

        
    }

</script>

<script id="frag-shader" type="notjs">
    precision mediump float;
    //color -> vetor de cores definido no vertex-shader
    varying vec4 color;
    //v_textCoord -> vetor de coordenadas de textura definido no vertex-shader
    varying vec2 v_textCoord;

    //Número do slot onde está a textura
    uniform sampler2D text;

    varying vec3 v_normal;

    //Conjunto de luzes direcionais
    uniform vec3 light_direction_1;
    uniform vec3 light_direction_2;

    uniform vec3 light_color;

    varying vec3 pointToLight;
    varying vec3 pointToCam;

    uniform int is_color;

    void main(){
        
        vec3 pToLight = normalize(pointToLight);
        vec3 pToCam = normalize(pointToCam);
        
        vec3 halfVec = normalize(pToCam+pToLight);

        vec3 v_normal_n = normalize(v_normal);

        //Normalizando vetores de luz direcional
        vec3 light_direction_1_n = normalize(-light_direction_1);
        vec3 light_direction_2_n = normalize(-light_direction_2);


        float light_directional_1 =dot(v_normal_n,light_direction_1_n);
        float light_directional_2 =dot(v_normal_n,light_direction_2_n);

        float light_pontual =dot(v_normal_n,pToLight);
        float light_especular = dot(v_normal_n, halfVec);

        vec3 color_tex;

        if (light_directional_1<0.0) light_directional_1=0.0;
        if (light_directional_2<0.0) light_directional_2=0.0;


        if (light_pontual<0.0) light_pontual=0.0;
        if (light_especular<0.0) light_especular = 0.0;

        if (is_color ==1){
            color_tex = color.rgb;
        }else{
            color_tex = texture2D(text,v_textCoord).rgb;
        }


        //gl_FragColor = vec4(light_color*light_directional_1* texture2D(text,v_textCoord).rgb,1);
        gl_FragColor.rgb =  .2*light_color*color_tex;
        gl_FragColor.rgb += .6*light_color*light_directional_1*color_tex;
        gl_FragColor.rgb += .3*light_color*light_directional_2*color_tex;
        gl_FragColor.rgb += .0*light_color*light_pontual* color_tex;
        gl_FragColor.rgb += .0*light_color*pow(light_especular,1000.0)*color_tex;
        gl_FragColor.a =1.0;
    }

</script>
<script src="webgl.js" ></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.2/math.js"></script>
</html>